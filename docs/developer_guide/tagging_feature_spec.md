# 태깅 기능 상세 명세

## 1. 개요
FileTagger 애플리케이션의 핵심 기능인 파일 태깅 시스템에 대한 상세 명세입니다. 사용자가 파일을 효율적으로 분류하고 관리할 수 있도록 직관적이고 효율적인 태깅 경험을 제공하는 것을 목표로 합니다. 특히, 수동 태깅 작업의 효율성을 극대화하고, 다양한 태그 추가 및 관리 방식을 지원합니다.

## 2. 요구사항

### 2.1. 태그 추가
- **새로운 태그 추가**: 사용자가 텍스트 입력 필드에 태그 이름을 입력한 후 `Enter` 키를 누르면 해당 태그가 현재 선택된 파일에 추가되어야 합니다.
- **기존 태그 선택 추가**: 애플리케이션 내에 존재하는 모든 태그 목록(`All Tags` 섹션)에서 특정 태그를 클릭하면 해당 태그가 현재 선택된 파일에 추가되어야 합니다.
- **디렉토리별 일괄 태그 추가**: 특정 디렉토리 내의 모든 파일 또는 선택된 파일들에 대해 일괄적으로 태그를 추가할 수 있는 기능을 제공해야 합니다.

### 2.2. 태그 수정/삭제
- **단일 태그 삭제**: 현재 파일에 부여된 태그들 중 특정 태그를 개별적으로 삭제할 수 있어야 합니다. (예: 태그 칩 옆의 'X' 버튼 클릭)
- **일괄 태그 삭제 (향후 확장)**: 여러 파일에 부여된 특정 태그를 일괄적으로 삭제할 수 있는 기능을 제공해야 합니다. (1차 개발 범위에서는 제외될 수 있으나, 설계 시 고려)

### 2.3. 태그 표시
- **태그 칩 형태 표시**: 현재 선택된 파일에 부여된 태그들은 시각적으로 구분하기 쉽고 상호작용이 용이한 "태그 칩(Tag Chip)" 형태로 표시되어야 합니다.

### 2.4. 추가 기능
- **태그 자동 완성**: 태그 입력 필드에서 사용자가 텍스트를 입력할 때, 기존에 존재하는 태그 목록을 기반으로 자동 완성 제안을 제공해야 합니다.
- **자주 사용하는 태그 빠른 선택**: 사용자가 자주 사용하는 태그 또는 미리 정의된 태그들을 빠르게 선택하여 추가할 수 있는 UI 요소를 제공해야 합니다.

## 3. UI/UX 설계

### 3.1. 태그 입력 및 표시 영역 (기존 `QLineEdit` 대체)
- **위치**: 파일 상세 정보 패널 내, 기존 `lineEdit_tags` 위치에 배치됩니다.
- **구성**:
    - **태그 칩 컨테이너**: 현재 파일에 할당된 태그 칩들이 동적으로 추가/제거되는 영역입니다. 태그 칩들은 가로로 나열되며, 공간이 부족할 경우 다음 줄로 자동 줄바꿈됩니다.
    - **새 태그 입력 필드**: 태그 칩 컨테이너 내부에 위치하며, 사용자가 새로운 태그를 입력할 수 있는 `QLineEdit` 형태의 위젯입니다. 이 필드에 입력 후 `Enter` 키를 누르면 태그 칩으로 변환됩니다.
    - **비활성화 정책**: 파일이 선택되지 않은 상태에서는 태그 입력 필드 및 태그 추가 관련 UI 요소(예: 태그 칩 추가 버튼)가 비활성화되어야 합니다.
- **태그 칩 (Tag Chip)**:
    - 각 태그는 시각적으로 구분되는 작은 사각형 또는 캡슐 형태의 위젯으로 표시됩니다.
    - 태그 이름과 함께 태그를 삭제할 수 있는 작은 'X' (또는 닫기) 버튼을 포함합니다. 'X' 버튼 클릭 시 해당 태그가 파일에서 제거됩니다.
    - **예시**: `[태그1 ⓧ] [태그2 ⓧ] [새 태그 입력...]`

### 3.2. 태그 자동 완성
- **적용 위치**: 새 태그 입력 필드 (`QLineEdit`).
- **동작**: 사용자가 텍스트를 입력하기 시작하면, `tag_manager`를 통해 가져온 모든 고유 태그 목록을 기반으로 드롭다운 형태의 자동 완성 목록을 제공합니다. 사용자는 목록에서 태그를 선택하거나 계속 입력할 수 있습니다.

### 3.3. 기존 태그 목록에서 선택하여 추가
- **위치**: `listWidget_all_tags` (현재 "All Tags (Filter)" 섹션).
- **동작**: `listWidget_all_tags`에서 특정 태그 항목을 클릭하면, 해당 태그가 현재 선택된 파일의 태그 목록에 즉시 추가됩니다. 이미 추가된 태그는 다시 클릭해도 중복 추가되지 않습니다.

### 3.4. 자주 사용하는 태그 빠른 선택 (Quick Tags)
- **위치**: 태그 입력 및 표시 영역 하단 또는 별도의 섹션.
- **구성**: 미리 정의되거나 사용자가 자주 사용하는 태그들을 버튼 또는 체크박스 형태로 나열합니다.
- **동작**: 버튼 클릭 시 해당 태그가 현재 파일에 추가/제거됩니다. (토글 방식)

### 3.5. 디렉토리별 일괄 태그 추가 UI
- **접근 방식**:
    - **옵션 1 (컨텍스트 메뉴)**: `treeView_dirs`에서 디렉토리를 우클릭했을 때 나타나는 컨텍스트 메뉴에 "Add Tags to Directory Contents..."와 같은 메뉴 항목을 추가합니다.
    - **옵션 2 (전용 버튼/다이얼로그)**: 메인 윈도우에 "Batch Tagging"과 같은 버튼을 추가하고, 클릭 시 별도의 다이얼로그를 띄워 디렉토리 선택 및 태그 입력/선택을 처리합니다.
- **다이얼로그 (예상)**:
    - **디렉토리 선택**: 일괄 태그를 적용할 디렉토리를 선택하는 필드. (옵션 1의 경우 이미 선택된 디렉토리로 자동 채워짐)
    - **태그 입력/선택**: 단일 파일 태깅과 유사하게 태그 칩 형태의 입력/표시 영역, 자동 완성, 기존 태그 목록 선택 기능을 제공합니다.
    - **적용 범위 선택**: "모든 파일", "특정 확장자 파일만" 등 적용 범위를 선택할 수 있는 옵션.
    - **실행 버튼**: 일괄 태그 추가 작업을 시작하는 버튼.

## 4. 구현 방향

### 4.1. 새로운 커스텀 위젯: `TagInputWidget`
- **파일**: `widgets/tag_input_widget.py` (새로 생성)
- **클래스**: `TagInputWidget(QWidget)`
- **내부 구성**:
    - `QHBoxLayout` 또는 `QFlowLayout` (태그 칩들을 유연하게 배치하기 위함)
    - `QLineEdit` (새 태그 입력 필드)
- **주요 메서드**:
    - `set_tags(tags: list[str])`: 현재 파일의 태그 목록을 받아 태그 칩들을 생성하고 표시합니다.
    - `add_tag(tag: str)`: 새로운 태그 칩을 추가합니다. 중복 태그는 허용하지 않습니다.
    - `remove_tag(tag: str)`: 특정 태그 칩을 제거합니다.
    - `get_tags() -> list[str]`: 현재 위젯에 표시된 모든 태그를 리스트로 반환합니다.
- **시그널**:
    - `tags_changed(tags: list[str])`: 태그가 추가되거나 삭제될 때마다 현재 태그 목록을 `list[str]` 형태로 방출합니다.

### 4.2. `main_window.py` 수정 사항

- **`__init__` 메서드**:
    - `TagInputWidget` 인스턴스 생성 및 UI에 배치 (기존 `lineEdit_tags` 대체).
    - `QCompleter` 인스턴스 생성 및 `TagInputWidget`의 입력 필드에 연결.
- **`connect_signals` 메서드**:
    - `TagInputWidget.tags_changed` 시그널을 `save_tags_for_selected_file` (또는 새로운 태그 저장 메서드)에 연결.
    - `listWidget_all_tags.itemClicked` 시그널을 수정하여 클릭된 태그를 `TagInputWidget.add_tag()` 메서드에 전달.
- **`on_file_selected` 메서드**:
    - 파일 선택 시 `tag_manager.get_tags_for_file()`로 태그를 가져와 `TagInputWidget.set_tags()`에 전달.
- **`save_tags_for_selected_file` 메서드**:
    - `lineEdit_tags.text()` 대신 `TagInputWidget.get_tags()`를 사용하여 태그 목록을 가져오도록 수정.
    - `tag_manager.update_tags`가 `list[str]` 형태의 태그를 받도록 변경 필요.
- **`update_all_tags_list` 메서드**:
    - `QCompleter`의 모델을 업데이트하는 로직 추가.
- **일괄 태그 추가 기능 구현**:
    - `open_directory_dialog`와 유사하게 디렉토리를 선택하고, 별도의 다이얼로그(`BatchTaggingDialog`)를 띄워 태그를 입력받고 `tag_manager`의 새로운 일괄 처리 메서드를 호출.

### 4.3. `tag_manager.py` 수정 사항

- **`update_tags(file_path: str, tags: list[str])`**:
    - 기존 `new_tags` (문자열) 대신 `list[str]` 형태의 태그를 받도록 시그니처 변경.
    - MongoDB에 태그를 저장하는 로직을 `list[str]`에 맞게 수정.
- **`add_tags_to_directory(directory_path: str, tags: list[str], recursive: bool = False, file_extensions: list[str] = None)` (새로운 메서드)**:
    - 특정 디렉토리 내의 파일들에 대해 일괄적으로 태그를 추가하는 로직 구현.
    - `os.walk` 등을 사용하여 디렉토리 내의 파일을 순회하고, 각 파일에 대해 `update_tags`를 호출.
    - `recursive` 및 `file_extensions` 옵션 처리.
- **`remove_tags_from_files(file_paths: list[str], tags_to_remove: list[str])` (향후 확장)**:
    - 여러 파일에서 특정 태그를 일괄적으로 제거하는 메서드.

### 4.4. `models/tagged_file.py` 수정 사항

- `TaggedFile` 클래스의 `tags` 속성이 `list[str]`를 기본으로 처리하도록 명확히 정의.
- `get_tags_as_string()`과 같은 문자열 변환 메서드는 필요에 따라 유지하거나 제거.

### 4.5. 성능 고려사항
- 대량의 파일에 태그를 일괄 적용할 경우, UI가 멈추지 않도록 백그라운드 스레드(QThread)를 사용하여 태그 저장 작업을 처리하는 것을 고려해야 합니다.
- MongoDB와의 통신 최적화 (예: 벌크 업데이트).


## 5. 개발 정책 반영

본 태깅 기능 구현은 프로젝트의 개발 정책을 엄격히 준수합니다.

### 5.1. 주석 및 문서화 정책
- 모든 주요 함수, 클래스, 메서드에는 [개발 가이드라인](coding_conventions.md)에 명시된 Google style docstring을 적용하여 코드의 '왜'와 '어떻게'를 명확히 설명합니다.
- 복잡한 로직이나 특정 결정의 배경에는 인라인 주석을 사용하여 추가적인 설명을 제공합니다.
- Docstring은 기획 문서(본 문서 포함)와 연동될 수 있도록 작성하여, 개발자뿐만 아니라 기획자 및 사용자도 기능의 의도를 이해하는 데 참고할 수 있도록 합니다.

### 5.2. 파일 분리 (모듈화) 정책
- UI, 비즈니스 로직, 데이터 모델 등 기능 단위 및 관심사별로 파일을 명확하게 분리합니다.
- `TagInputWidget`과 같은 새로운 UI 컴포넌트는 `widgets/` 디렉토리에, 핵심 비즈니스 로직은 `core/` 디렉토리에, 데이터 모델은 `models/` 디렉토리에 위치시킵니다.
- 테스트 코드는 원본 코드와 동일한 디렉토리 구조를 가지는 `tests/` 디렉토리 내에 위치시켜 코드 유지보수성과 협업 효율성을 높입니다.

## 6. 향후 기능 고려사항: 태그 검색 시 자동 완성

현재 태그 추가/수정 시의 UI/UX 정책(파일 미선택 시 비활성화)과 별개로, 향후 태그 검색 기능 구현 시에는 다음과 같은 사항을 고려합니다.

-   **필요성**: 사용자가 기존 태그 목록에서 원하는 태그를 쉽게 찾고 입력할 수 있도록 태그 검색 기능에 자동 완성을 제공합니다.
-   **참고 및 재사용**: `TagInputWidget`에 구현된 태그 자동 완성 로직을 참고하여 재사용하거나, 검색 기능의 특성에 맞게 확장하여 구현합니다.
-   **UI/UX 분리**: 태그 추가/수정 시의 비활성화 정책과 태그 검색 시의 자동 완성은 서로 다른 UI/UX 맥락으로 구분하여 설계 및 구현합니다. 검색 기능은 파일 선택 여부와 관계없이 독립적으로 동작할 수 있도록 합니다.

---
