---
status: Approved
---
## 개발 요청 명세 (Development Request Specification)

*   **문서 ID**: `DRS-20250711-009`
*   **작성일**: `2025년 7월 11일`
*   **작성자**: `Gemini (기획팀)`
*   **관련 기능/모듈**: `태그 검색`
*   **관련 이슈**: `docs/issues.md에 새로운 이슈로 등록 예정`

---

## 1. 개요 (Overview)

### 1.1. 목적
사용자가 파일에 부여된 태그를 기반으로 파일을 효율적으로 검색하고 필터링할 수 있는 기능을 제공합니다. 이를 통해 대량의 파일 중에서 특정 태그가 부여된 파일들을 빠르게 찾아내고, 복합적인 태그 조건으로 정밀한 검색을 수행할 수 있도록 합니다.

### 1.2. 해결하는 사용자 문제
- **파일 검색의 어려움**: 수많은 파일 중에서 특정 태그가 부여된 파일을 찾기 어려운 문제
- **복합 조건 검색 부재**: 여러 태그를 조합하여 검색할 수 없는 문제
- **검색 결과 시각화 부족**: 검색 결과를 직관적으로 확인하기 어려운 문제

### 1.3. 시스템에서의 역할
태그 기반 검색 기능은 FileTagger 애플리케이션의 핵심 기능 중 하나로, 태깅 시스템의 가치를 극대화하는 역할을 합니다. 사용자가 태그를 통해 파일을 분류한 후, 그 태그를 활용하여 효율적으로 파일을 찾을 수 있게 함으로써 태깅 시스템의 실용성을 크게 향상시킵니다.

---

## 2. 요구사항 (Requirements)

### 2.1. 기능 요구사항 (Functional Requirements)

#### 2.1.1. 기본 태그 검색
- **단일 태그 검색**: 사용자가 하나의 태그를 입력하면 해당 태그가 부여된 모든 파일을 검색 결과로 표시할 수 있어야 합니다.
- **태그 자동 완성**: 검색 입력 필드에서 기존에 존재하는 태그 목록을 기반으로 자동 완성 기능을 제공해야 합니다.
- **대소문자 구분 없는 검색**: 태그 검색 시 대소문자를 구분하지 않아야 합니다.

#### 2.1.2. 복합 태그 검색
- **AND 검색**: 여러 태그를 쉼표(,)로 구분하여 입력하면 AND 조건으로 검색할 수 있어야 합니다. (예: "중요,문서" → 두 태그가 모두 부여된 파일만 검색)
- **OR 검색**: 여러 태그를 파이프(|)로 구분하여 입력하면 OR 조건으로 검색할 수 있어야 합니다. (예: "중요|긴급" → 두 태그 중 하나라도 부여된 파일 검색)
- **NOT 검색**: 제외할 태그 앞에 별표(*)를 붙이면 해당 태그가 없는 파일을 검색할 수 있어야 합니다. (예: "*삭제예정" → "삭제예정" 태그가 없는 파일만 검색)

#### 2.1.3. 검색 결과 관리
- **검색 결과 표시**: 검색 조건에 맞는 파일들을 파일 목록에 표시해야 합니다.
- **검색 결과 개수 표시**: 검색 결과로 찾은 파일의 개수를 표시해야 합니다.
- **검색 조건 표시**: 현재 적용된 검색 조건을 명확하게 표시해야 합니다.
- **검색 초기화**: 검색 조건을 초기화하여 모든 파일을 다시 표시할 수 있어야 합니다.

#### 2.1.4. 검색 히스토리
- **최근 검색어 저장**: 사용자가 수행한 최근 검색어들을 저장하고 빠르게 재사용할 수 있어야 합니다.
- **검색어 즐겨찾기**: 자주 사용하는 검색 조건을 즐겨찾기로 저장할 수 있어야 합니다.

### 2.2. 비기능 요구사항 (Non-Functional Requirements)

#### 2.2.1. 성능 (개선된 요구사항)
- **기본 검색 응답 시간**: 단일 태그 검색은 500ms 이내에 결과를 표시해야 합니다.
- **복합 검색 응답 시간**: 복합 조건 검색은 1초 이내에 결과를 표시해야 합니다.
- **실시간 검색 응답 시간**: 사용자 입력 중 실시간 검색은 300ms 이내에 결과를 업데이트해야 합니다.
- **대용량 데이터 처리**: 수천 개의 파일과 태그가 있어도 성능 저하 없이 검색이 가능해야 합니다.
- **메모리 사용량**: 검색 기능이 전체 애플리케이션 메모리 사용량의 10% 이내로 제한되어야 합니다.

#### 2.2.2. 사용성
- **직관적인 UI**: 검색 기능이 직관적이고 사용하기 쉬워야 합니다.
- **키보드 단축키**: 검색 필드에 빠르게 포커스를 이동할 수 있는 단축키(Ctrl+F)를 제공해야 합니다.
- **검색 도움말**: 복합 검색 문법에 대한 도움말을 제공해야 합니다.

#### 2.2.3. 확장성
- **검색 조건 확장**: 향후 파일명, 파일 크기, 수정 날짜 등 다른 조건과 조합할 수 있도록 설계해야 합니다.
- **검색 알고리즘 개선**: 더 정교한 검색 알고리즘을 적용할 수 있도록 모듈화된 구조로 설계해야 합니다.

---

## 3. UI/UX 설계 (User Interface / User Experience Design)

### 3.1. 검색 UI 구성 (수정된 설계)

#### 3.1.1. 통합 검색 툴바 (메뉴바 아래 배치)
- **위치**: 메뉴바 바로 아래, 메인 윈도우 상단에 수평 툴바 형태로 배치
- **크기**: 전체 너비, 높이 40px
- **배경**: 연한 회색 배경(#f8f9fa), 하단 테두리(#dee2e6)
- **구성 요소** (왼쪽부터 순서대로):
  
  **1. 파일명 검색 영역** (전체 너비의 25%)
  - **파일명 입력 필드**: `QLineEdit`, 플레이스홀더: "파일명 검색..."
  - **확장자 필터**: `QLineEdit`, 플레이스홀더: ".jpg, .png", 파일명 필드 바로 옆에 배치
  
  **2. 태그 검색 영역** (전체 너비의 25%)
  - **태그 입력 필드**: `QLineEdit`, 플레이스홀더: "태그 검색 (예: 중요,문서|긴급)"
  
  **3. 검색 제어 버튼들** (각 32px)
  - **고급 검색 토글 버튼**: 아이콘: 화살표 (▼/▲), 클릭 시 고급 검색 패널 표시/숨김
  - **검색 실행 버튼**: 아이콘: 돋보기, Enter 키와 동일한 동작
  - **검색 초기화 버튼**: 아이콘: X, 모든 검색 조건 초기화
  - **검색 히스토리 버튼**: 아이콘: 시계, 최근 검색어 드롭다운
  
  **4. 검색 결과 표시** (우측 정렬)
  - **검색 결과 개수**: "검색 결과: 123개 파일" 형태로 표시
  - **검색 조건 요약**: 현재 적용된 검색 조건들을 간단히 표시

#### 3.1.2. 고급 검색 패널 (검색 툴바 아래)
- **표시 방식**: 검색 툴바 아래에 슬라이드 다운 애니메이션으로 표시
- **크기**: 전체 너비, 높이 120px
- **배경**: 흰색 배경, 상단 테두리(#dee2e6)
- **구성 요소**:
  
  **파일명 고급 검색 영역** (왼쪽 20%):
  - **정확한 파일명**: `QLineEdit`, 플레이스홀더: "정확한 파일명"
  - **부분 일치**: `QLineEdit`, 플레이스홀더: "파일명에 포함된 텍스트"
  - **정규식**: `QCheckBox`, "정규식 사용"
  
  **태그 고급 검색 영역** (오른쪽 80%):
  - **AND 검색**: `QLineEdit`, 플레이스홀더: "AND 조건 태그들 (쉼표로 구분)"
  - **OR 검색**: `QLineEdit`, 플레이스홀더: "OR 조건 태그들 (파이프로 구분)"
  - **NOT 검색**: `QLineEdit`, 플레이스홀더: "제외할 태그들 (별표로 시작)"

#### 3.1.3. 검색 결과 표시 영역
- **검색 결과 개수**: 검색 툴바 우측에 "검색 결과: 123개 파일" 형태로 표시
- **검색 조건 표시**: 검색 결과 개수 아래에 현재 검색 조건 요약 표시
- **검색 결과 하이라이트**: 
  - 검색된 파일들을 파일 목록에서 연한 파란색 배경으로 강조
  - 검색 조건과 일치하는 부분을 노란색 배경으로 하이라이트
  - 검색 조건과 일치하지 않는 파일들은 반투명 처리

### 3.2. 검색 타입별 동작 (구체화된 플로우)

#### 3.2.1. 파일명 검색
1. 파일명 입력 필드에 파일명 입력
2. 확장자 필터에 원하는 확장자 입력 (선택사항)
3. 현재 디렉토리 및 하위 디렉토리에서 파일명 검색
4. 검색 결과를 파일 목록에 표시

#### 3.2.2. 태그 검색
1. 태그 입력 필드에 태그 검색어 입력 (기호 기반 문법)
2. 고급 검색 패널에서 복합 조건 설정 가능
3. 태그 기반으로 파일 검색 및 결과 표시

#### 3.2.3. 복합 검색 (파일명 + 태그)
1. 파일명 입력 필드와 태그 입력 필드에 각각 조건 입력
2. 두 조건을 모두 만족하는 파일들만 검색 결과로 표시
3. 검색 조건 요약에 "파일명: '*.txt' AND 태그: '중요,문서'" 형태로 표시

#### 3.2.4. 전역 검색
1. 검색 타입을 "전역 검색"으로 선택 (별도 콤보박스 추가 고려)
2. 전체 작업 공간에서 파일명, 태그, 확장자 등 모든 조건으로 검색
3. 검색 결과를 파일 목록에 표시

### 3.3. 기존 기능 통합 방안

#### 3.3.1. 디렉토리 트리 위젯 수정
- **제거할 요소들**:
  - `global_file_search_input` (통합 검색 툴바로 이동)
  - `tag_search_input` (통합 검색 툴바로 이동)
  - `extensions_input` (통합 검색 툴바의 파일명 영역으로 이동)

- **유지할 요소들**:
  - 파일 시스템 트리 뷰
  - 컨텍스트 메뉴 기능
  - 디렉토리 선택 기능
  - `show_files_checkbox` (체크박스 형태로 유지)
  - `recursive_checkbox` (체크박스 형태로 유지)

#### 3.3.2. 메인 윈도우 레이아웃 수정
```python
# main_window.py 수정사항
class MainWindow(QMainWindow):
    def __init__(self):
        # ... 기존 코드 ...
        
        # 통합 검색 툴바 추가
        self.search_toolbar = SearchToolbar()
        self.addToolBar(self.search_toolbar)
        
        # 3분할 레이아웃 유지 (디렉토리 트리는 옵션 체크박스 유지)
        self.mainSplitter.insertWidget(0, self.directory_tree)
        self.mainSplitter.insertWidget(1, self.splitter)
        self.mainSplitter.insertWidget(2, self.tag_control)
        
        # 검색 시그널 연결
        self.search_toolbar.search_requested.connect(self.on_search_requested)
        self.search_toolbar.search_cleared.connect(self.on_search_cleared)
```

### 3.4. 시각적 디자인 (구체화된 스타일)

#### 3.4.1. 검색 툴바 스타일
- **배경**: 연한 회색 배경(#f8f9fa)
- **테두리**: 하단 테두리(#dee2e6), 두께 1px
- **버튼**: 플랫 스타일, 호버 시 파란색 배경(#e3f2fd)
- **입력 필드**: 둥근 모서리(4px), 포커스 시 파란색 테두리(#0078d4)
- **검색 영역 구분**: 각 검색 영역 사이에 세로 구분선 추가

#### 3.4.2. 검색 결과 표시
- **검색 결과 파일**: 연한 파란색 배경(#e3f2fd), 테두리 강조
- **검색 조건 하이라이트**: 노란색 배경(#fff3cd), 굵은 글씨체
- **검색 히스토리**: 회색 배경(#f8f9fa), 호버 시 파란색 배경

### 3.5. 키보드 단축키
- **Ctrl+F**: 파일명 검색 필드에 포커스
- **Ctrl+T**: 태그 검색 필드에 포커스
- **Ctrl+Shift+F**: 고급 검색 패널 토글
- **Ctrl+L**: 검색 히스토리 드롭다운 표시
- **Ctrl+E**: 확장자 필터 입력 필드에 포커스
- **Ctrl+R**: 재귀 검색 옵션 토글 (디렉토리 트리의 체크박스)

---

## 4. 기술적 고려사항 (Technical Considerations)

### 4.1. 아키텍처 영향

#### 4.1.1. 새로운 컴포넌트 (상세 인터페이스)

**`SearchWidget` (widgets/search_widget.py)**
```python
class SearchWidget(QWidget):
    def __init__(self, parent=None):
        # 검색 입력 필드, 버튼들, 고급 검색 패널 초기화
    
    def get_search_query(self) -> str:
        """현재 검색 쿼리를 반환"""
    
    def set_search_query(self, query: str):
        """검색 쿼리를 설정"""
    
    def clear_search(self):
        """검색 조건을 초기화"""
    
    def show_advanced_panel(self, show: bool):
        """고급 검색 패널 표시/숨김"""
    
    # 시그널
    search_requested = pyqtSignal(str)  # 검색 요청
    search_cleared = pyqtSignal()       # 검색 초기화
    advanced_search_requested = pyqtSignal(dict)  # 고급 검색 요청
```

**`SearchManager` (core/search_manager.py)**
```python
class SearchManager:
    def __init__(self, tag_manager: TagManager):
        self.tag_manager = tag_manager
        self.search_history = SearchHistory()
    
    def search_files(self, query: str) -> List[str]:
        """기본 검색: 단일 태그 또는 간단한 복합 검색"""
    
    def advanced_search(self, conditions: dict) -> List[str]:
        """고급 검색: 복합 조건 검색"""
    
    def parse_search_query(self, query: str) -> dict:
        """검색 쿼리를 파싱하여 조건 딕셔너리로 변환"""
    
    def get_search_suggestions(self, partial_query: str) -> List[str]:
        """검색 제안 목록 반환"""
    
    def save_search_history(self, query: str):
        """검색 히스토리 저장"""
    
    def get_search_history(self, limit: int = 10) -> List[str]:
        """검색 히스토리 반환"""
```

**`SearchHistory` (core/search_history.py)**
```python
class SearchHistory:
    def __init__(self, max_history: int = 50):
        self.max_history = max_history
        self.history = []
    
    def add_search(self, query: str):
        """검색어를 히스토리에 추가"""
    
    def get_recent_searches(self, limit: int = 10) -> List[str]:
        """최근 검색어 목록 반환"""
    
    def clear_history(self):
        """검색 히스토리 초기화"""
    
    def save_to_database(self):
        """데이터베이스에 히스토리 저장"""
    
    def load_from_database(self):
        """데이터베이스에서 히스토리 로드"""
```

#### 4.1.2. 기존 컴포넌트 수정

**`MainWindow` 수정사항**:
- `SearchWidget` 인스턴스 생성 및 UI에 배치
- 검색 시그널 연결 및 검색 결과 처리
- 파일 목록 필터링 및 하이라이트 적용

**`FileListWidget` 수정사항**:
- 검색 결과 필터링 메서드 추가
- 검색 조건 하이라이트 표시 기능
- 검색 결과 개수 표시

**`TagManager` 수정사항**:
- 태그 기반 검색 쿼리 처리 메서드 추가
- MongoDB 인덱스 생성 및 최적화

### 4.2. 데이터 모델 변경 (상세 명세)

#### 4.2.1. 검색 히스토리 저장 구조
```python
# MongoDB 컬렉션: search_history
{
    "_id": ObjectId,
    "query": str,           # 검색 쿼리
    "timestamp": datetime,  # 검색 시간
    "result_count": int,    # 검색 결과 개수
    "user_id": str,         # 사용자 ID (향후 확장용)
    "is_favorite": bool     # 즐겨찾기 여부
}
```

#### 4.2.2. 기존 TaggedFile 모델과의 연관관계
- `TaggedFile` 모델은 변경 없음
- 검색 시 `TaggedFile.tags` 필드를 활용하여 검색 수행
- 검색 결과는 `TaggedFile.file_path` 목록으로 반환

### 4.3. 성능 최적화 (구체적 전략)

#### 4.3.1. MongoDB 인덱싱
```javascript
// 태그 기반 검색을 위한 복합 인덱스
db.tagged_files.createIndex({ "tags": 1, "file_path": 1 })

// 검색 히스토리를 위한 인덱스
db.search_history.createIndex({ "timestamp": -1 })
db.search_history.createIndex({ "user_id": 1, "timestamp": -1 })
```

#### 4.3.2. 캐싱 전략
- **검색 결과 캐시**: Redis 또는 메모리 캐시로 최근 검색 결과 저장
- **태그 목록 캐시**: 전체 태그 목록을 메모리에 캐시하여 자동 완성 성능 향상
- **캐시 TTL**: 검색 결과 5분, 태그 목록 1시간

#### 4.3.3. 비동기 검색
- **백그라운드 스레드**: 대용량 검색 시 QThread 사용
- **진행률 표시**: 검색 진행 상황을 프로그레스 바로 표시
- **검색 취소**: 사용자가 검색을 중단할 수 있는 기능

### 4.4. 재사용 가능한 컴포넌트
- **`TagInputWidget`**: 태그 자동 완성 로직 재사용
- **`TagChip`**: 검색 조건 표시에 활용
- **`QCompleter`**: 검색 자동 완성에 활용

---

## 5. 테스트 시나리오 (Test Scenarios)

### 5.1. 기본 검색 테스트
- **단일 태그 검색**: 하나의 태그로 검색하여 정확한 결과 반환 확인
- **대소문자 무관 검색**: 대소문자를 다르게 입력해도 동일한 결과 반환 확인
- **존재하지 않는 태그 검색**: 존재하지 않는 태그로 검색 시 빈 결과 반환 확인

### 5.2. 복합 검색 테스트
- **AND 검색**: 두 개 이상의 태그를 쉼표로 구분하여 AND 조건 검색 확인
- **OR 검색**: 두 개 이상의 태그를 파이프로 구분하여 OR 조건 검색 확인
- **NOT 검색**: 별표로 시작하는 태그를 제외한 검색 결과 반환 확인
- **복합 조건 검색**: 쉼표, 파이프, 별표를 조합한 복잡한 검색 조건 처리 확인

### 5.3. UI/UX 테스트
- **자동 완성 기능**: 태그 입력 시 자동 완성 제안이 정확히 표시되는지 확인
- **검색 히스토리**: 검색 히스토리가 올바르게 저장되고 재사용되는지 확인
- **검색 초기화**: 검색 초기화 버튼으로 모든 검색 조건이 해제되는지 확인
- **고급 검색 패널**: 토글 버튼으로 패널이 올바르게 표시/숨김되는지 확인

### 5.4. 성능 테스트
- **기본 검색 성능**: 단일 태그 검색이 500ms 이내에 완료되는지 확인
- **복합 검색 성능**: 복합 조건 검색이 1초 이내에 완료되는지 확인
- **실시간 검색 성능**: 입력 중 실시간 검색이 300ms 이내에 업데이트되는지 확인
- **대용량 데이터 검색**: 수천 개의 파일과 태그가 있는 환경에서 검색 성능 확인
- **메모리 사용량**: 검색 기능이 메모리 사용량 제한을 준수하는지 확인

### 5.5. 에러 처리 테스트
- **잘못된 검색 문법**: 잘못된 검색 문법 입력 시 적절한 에러 메시지 표시 확인
- **네트워크 오류**: 데이터베이스 연결 오류 시 적절한 처리 확인
- **권한 오류**: 파일 접근 권한이 없는 경우의 처리 확인

---

## 6. 개발 일정 및 우선순위

### 6.1. 개발 단계별 일정
1. **1단계: 기본 검색 기능 (2-3주)**
   - `SearchWidget` 기본 UI 구현
   - `SearchManager` 기본 검색 로직 구현
   - 단일 태그 검색 및 자동 완성 기능
   - 기본 성능 최적화 (500ms 목표)

2. **2단계: 복합 검색 기능 (2-3주)**
   - 검색 쿼리 파싱 로직 구현
   - 복합 검색 (AND/OR/NOT) 기능 구현
   - 고급 검색 패널 UI 구현
   - 복합 검색 성능 최적화 (1초 목표)

3. **3단계: 검색 히스토리 (1-2주)**
   - `SearchHistory` 클래스 구현
   - 검색 히스토리 UI 구현
   - 데이터베이스 저장/로드 기능
   - 즐겨찾기 기능

4. **4단계: 성능 최적화 (1-2주)**
   - MongoDB 인덱스 최적화
   - 캐싱 시스템 구현
   - 실시간 검색 구현 (300ms 목표)
   - 메모리 사용량 최적화

### 6.2. 마일스톤
- **Week 2**: 기본 검색 기능 프로토타입 완성
- **Week 5**: 복합 검색 기능 완성
- **Week 7**: 검색 히스토리 기능 완성
- **Week 9**: 전체 기능 통합 및 최적화 완료

### 6.3. 참고 자료
- **기존 태깅 기능 명세**: `docs/developer_guide/tagging_feature_spec.md`
- **UI 위젯 시그널 참조**: `docs/developer_guide/ui_widgets_signals_reference.md`
- **MongoDB 검색 쿼리 최적화 가이드**: MongoDB 공식 문서

### 6.4. 제약 사항
- **기존 태깅 시스템과의 호환성**: 현재 구현된 태깅 시스템을 해치지 않아야 함
- **성능 제약**: 검색 기능이 전체 애플리케이션 성능에 부정적 영향을 주지 않아야 함
- **UI 일관성**: 기존 UI/UX 디자인 원칙을 준수해야 함
- **메모리 제약**: 검색 기능이 전체 메모리 사용량의 10% 이내로 제한되어야 함

---

## 7. 검색 문법 명세 (Search Syntax Specification)

### 7.1. 기본 검색 문법
- **단일 태그**: `중요` → "중요" 태그가 부여된 파일 검색
- **AND 검색**: `중요,문서` → "중요"와 "문서" 태그가 모두 부여된 파일 검색
- **OR 검색**: `중요|긴급` → "중요" 또는 "긴급" 태그가 부여된 파일 검색
- **NOT 검색**: `*삭제예정` → "삭제예정" 태그가 없는 파일 검색

### 7.2. 복합 검색 문법
- **괄호 사용**: `(중요|긴급),문서` → "중요" 또는 "긴급" 태그가 있고, 동시에 "문서" 태그가 있는 파일 검색
- **복합 조건**: `중요,문서,*임시` → "중요"와 "문서" 태그가 있고, "임시" 태그가 없는 파일 검색

### 7.3. 특수 문자 처리
- **공백 포함 태그**: `"중요 문서"` → 공백이 포함된 태그 검색
- **특수 문자**: `#프로젝트` → 특수 문자가 포함된 태그 검색

---

*이 문서는 태그 기반 검색 기능의 개발 요청 명세서입니다. 개발팀은 이 명세를 바탕으로 기능을 구현하고, 기획팀과의 지속적인 소통을 통해 요구사항을 명확히 하여 최적의 사용자 경험을 제공하도록 합니다.* 